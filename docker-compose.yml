version: '3.7'

# service: A running container with definitions and configurations about how each container image will run.
services:
    # --------------------------------------------- ReactJS
    react_app:
        container_name: frontend
        build:
            context: ./frontend
            dockerfile: Dockerfile
        ports:
            - 3000:3000
            # - "${FRONTEND_PORT}:${FRONTEND_PORT}"
        volumes:
            - ./frontend/_frontend_volume:/nonsense
            # here it was myapp and now I put nonsense... it should be the direcotry inside the container that we want to save things on the host machine... maybe that is only necessary for the database???
            # - ./_frontend_volume:/myapp:rw,uid=<501>,gid=<20>
            # - ./path/on/host:/myapp/node_modules/.cache
#        restart: on-failure
        depends_on:
            - nest_app
            - postgres_db
#            nest_app:
#                condition: service_started
#            postgres_db:
#                condition: service_started

    # --------------------------------------------- nestJS
    nest_app:
        container_name: backend
        build:
            context: ./backend
            dockerfile: Dockerfile
        ports:
            - 3001:3001
            # - "${BACKEND_PORT}:${BACKEND_PORT}"
        volumes:
            - ./backend/_backend_volume:/nonsense
            # here it was myapp and now I put nonsense... it should be the direcotry inside the container that we want to save things on the host machine... maybe that is only necessary for the database???
              # - ./_backend_volume:/myapp:rw,uid=<501>,gid=<20>
#        env_file:
#            - ./.env
#        restart: on-failure
        depends_on:
            - postgres_db
#            postgres_db:
#                condition: service_healthy
        environment:
            - POSTGRES_HOST=database_host
            - POSTGRES_PORT=5432
            - POSTGRES_USER=transcendence_user
            - POSTGRES_PASSWORD=novogeslo1
            - POSTGRES_DB=mydb

    # --------------------------------------------- PostgreSQL
    postgres_db:
        container_name: database
        image: postgres
        ports:
            - 5432:5432
            # - "${POSTGRES_PORT}:${POSTGRES_PORT}"
        volumes:
            - ./backend/_database_volume:/var/lib/postgresql/data
#        env_file:
#            - ./.env
#        restart: unless-stopped
        environment:
            - POSTGRES_USER=transcendence_user
            - POSTGRES_PASSWORD=novogeslo1
            - POSTGRES_DB=mydb
            # - POSTGRES_DB=${POSTGRES_DB}
            # - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
            # - POSTGRES_USER=${POSTGRES_USER}
        # healthcheck:
        #   test: pg_isready -U ${POSTGRES_USER}
        #   # test: [ "pg_isready", "-U", "${POSTGRES_USER}" ]
        #   interval: 10s
        #   timeout: 5s
        #   retries: 5
        #   start_period: 30s
        # healthcheck:
        #   test: /healthchecks/postgres.sh
        #   interval: "5s"

# volumes:
#      - ./<host_machine_dir_path>:/<container_data_dir_path>
# This line specifies a volume mapping between the a directory on the host machine (left side of the colon) and the
# a data directory inside the container (right side of the colon). This means that the contents of the host machine
# directory will be synchronized/mounted into the directory inside the container.
# This allows you to change the application code on your host machine and the changes will be reflected inside the
# container, enabling live-reloading without rebuilding the container each time a change is made.
